# java-prog-intro

#### [1. Сканнер](#сканнер)
#### [2. Статистика слов](#статистика-слов)
#### [3. Разметка](#разметка)
#### [4. Markdown to HTML](#markdown-to-html)
#### [5. Игра m,n,k](#игра-mnk)
#### [6. Выражения](#выражения)
#### [7. Разбор выражений с обработкой ошибок](#разбор-выражений-с-обработкой-ошибок)


### Сканнер
* Реализован свой аналог класса `Scanner` на основе Reader.
* Разработанный `Scanner` применен для решения задания «Статистика слов».
* Использовано блочное чтение. Код, управляющий чтением, общий.
* Код, выделяющий числа и слова, общий.
* На вход подаются десятичные и восьмиричные числа
* Восьмиричные числа имеют суффикс `o`

### Статистика слов
* Класс Wspp, подсчитывает статистику встречаемости слов во входном файле.
* Словом называется непрерывная последовательность букв, апострофов и тире (Unicode category Punctuation, Dash). Для подсчета статистики, слова приводятся к нижнему  регистру.
* Выходной файл содержит все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова выведена одна строка, содержащая слово, число его вхождений во входной файл и номера вхождений этого слова среди всех слов во входном файле.
* Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
* Программа работает за линейное от размера входного файла.
* Реализован класс IntList, компактно хранящий список целых чисел.
* На вход подаются десятичные и восьмиричные числа
* Восьмиричные числа имеют суффикс `o`

### Разметка
*  Разработан набор классов для текстовой разметки.
*  Класс `Paragraph` может содержать произвольное число других элементов разметки и текстовых элементов.
*  Класс `Text` – текстовый элемент.
*  Классы разметки `Emphasis`, `Strong`, `Strikeout` – выделение, сильное выделение и зачеркивание. Элементы разметки могут содержать произвольное число других элементов разметки и текстовых элементов.
*  Все классы реализуют метод `toMarkdown(StringBuilder)`, который генерирует Markdown-разметку по следующим правилам:
    * текстовые элементы выводятся как есть;
    * выделенный текст окружается символами `*`;
    * сильно выделенный текст окружается символами `__`;
    * зачеркнутый текст окружается символами `~`.
*  Пример:
    
        Paragraph paragraph = new Paragraph(List.of(
            new Strong(List.of(
                new Text("1"),
                new Strikeout(List.of(
                    new Text("2"),
                    new Emphasis(List.of(
                        new Text("3"),
                        new Text("4")
                    )),
                    new Text("5")
                )),
                new Text("6")
            ))
        ));
    
    Вызов `paragraph.toMakdown(new StringBuilder())` заполняет переданный StringBuilder следующим содержимым:
    
        __1~2*34*5~6__
        
* Дополнительно реализован метод `toHtml`, генерирующий HTML-разметку:
    * выделеный текст окружается тегом `em`;
    * сильно выделеный текст окружается тегом `strong`;
    * зачеркнутый текст окружается тегом `s`.
* Добававлена поддержка:
    * Нумерованных списков (класс `OrderedList`, тег `ol`): последовательность элементов
    * Ненумерованных списков (класс `UnorderedList`, тег `ul`): последовательность элементов
    * Элементов списка (класс `ListItem`, тег `li`): последовательность абзацев и списков

### Markdown to HTML
*  Конвертер из Markdown-разметки в HTML.
*  Конвертер поддерживает следующие возможности:
*  Абзацы текста разделяются пустыми строками.
*  Элементы строчной разметки: выделение (`*` или `_`), сильное выделение (`**` или `__`), зачеркивание (`--`), код (`)
*  Заголовки (# * уровень заголовка)
*  Конвертер называется md2html.Md2Html и принимает два аргумента: название входного файла с Markdown-разметкой и название выходного файла c HTML-разметкой.
*  Пример. Входной файл
      ```
      # Заголовок первого уровня

      ## Второго

      ### Третьего ## уровня

      #### Четвертого
      # Все еще четвертого

      Этот абзац текста,
      содержит две строки.

          # Может показаться, что это заголовок.
      Но нет, это абзац начинающийся с `#`.

      #И это не заголовок.

      ###### Заголовки могут быть многострочными
      (и с пропуском заголовков предыдущих уровней)

      Мы все любим *выделять* текст _разными_ способами.
      **Сильное выделение**, используется гораздо реже,
      но __почему бы и нет__?
      Немного --зачеркивания-- еще ни кому не вредило.
      Код представляется элементом `code`.

      Обратите внимание, как экранируются специальные
      HTML-символы, такие как `<`, `>` и `&`.

      Знаете ли вы, что в Markdown, одиночные * и _
      не означают выделение?
      Они так же могут быть заэкранированы
      при помощи обратного слэша: \*.



      Лишние пустые строки должны игнорироваться.

      Любите ли вы *вложеные __выделения__* так,
      как __--люблю--__ их я?
      ```

*  Выходной файл

      ```
      <h1>Заголовок первого уровня</h1>
      <h2>Второго</h2>
      <h3>Третьего ## уровня</h3>
      <h4>Четвертого
      # Все еще четвертого</h4>
      <p>Этот абзац текста,
      содержит две строки.</p>
      <p>    # Может показаться, что это заголовок.
      Но нет, это абзац начинающийся с <code>#</code>.</p>
      <p>#И это не заголовок.</p>
      <h6>Заголовки могут быть многострочными
      (и с пропуском заголовков предыдущих уровней)</h6>
      <p>Мы все любим <em>выделять</em> текст <em>разными</em> способами.
      <strong>Сильное выделение</strong>, используется гораздо реже,
      но <strong>почему бы и нет</strong>?
      Немного <s>зачеркивания</s> еще ни кому не вредило.
      Код представляется элементом <code>code</code>.</p>
      <p>Обратите внимание, как экранируются специальные
      HTML-символы, такие как <code>&lt;</code>, <code>&gt;</code> и <code>&amp;</code>.</p>
      <p>Знаете ли вы, что в Markdown, одиночные * и _
      не означают выделение?
      Они так же могут быть заэкранированы
      при помощи обратного слэша: *.</p>
      <p>Лишние пустые строки должны игнорироваться.</p>
      <p>Любите ли вы <em>вложеные <strong>выделения</strong></em> так,
      как <strong><s>люблю</s></strong> их я?</p>
      ```
      
### Игра m,n,k
*  Игру m,n,k (k в ряд на доске m×n).
*  Добавлена обработка ошибок ввода пользователя. В случае ошибочного хода пользователь имеет возможность сделать другой ход.
*  Добавлена обработка ошибок игроков. В случае ошибки игрок автоматически проигрывает.
*  Доска производит обработку хода (проверку корректности, изменение состояния и определение результата) за O(k).
*  Предотвращено жульничество: у игрока нет возможности достать `Board` из `Position`.
*  Турнир
   *  В рамках кругового турнира каждый с каждым должен сыграть две партии, по одной каждым цветом.
   *  Таблица очков по схеме:
         * 3 очка за победу;
         * 1 очко за ничью;
         * 0 очков за поражение.
*  Добававлена поддержка препятствий — клеток, в которые запрещено делать ходы.


### Выражения
*  Разработаны классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide` для вычисления выражений с одной переменной в типе int (интерфейс `Expression`).
*  Классы позволяют составлять выражения вида
      ```
      new Subtract(
          new Multiply(
              new Const(2),
              new Variable("x")
          ),
          new Const(3)
      ).evaluate(5)
      ```
*  При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра методу `evaluate`. 
*  Метод `toString` выдавает запись выражения в полноскобочной форме. Например
      ```
      new Subtract(
          new Multiply(
              new Const(2),
              new Variable("x")
          ),
          new Const(3)
      ).toString()
      ```            
выдает ((2 * x) - 3).
*  Метод `toMiniString` (интерфейс `ToMiniString`) выдает выражение с минимальным числом скобок. Например
      ```
      new Subtract(
          new Multiply(
              new Const(2),
              new Variable("x")
          ),
          new Const(3)
      ).toMiniString()
      ```            
выдает 2 * x - 3.
*  Реализован метод `equals`, проверяющий, что два выражения совпадают.
*  Дополнительно реализована поддержка выражений с тремя переменными: x, y и z. Интерфейс `TripleExpression`.
*  Дополнительно реализованы вычисления в типе double. Интерфейс `DoubleExpression`.


### Разбор выражений с обработкой ошибок
*  В записи выражения могут встречаться:
      *  бинарные операции: умножение *, деление /, сложение + и вычитание -;
      *  унарный минус -;
      *  переменные x, y и z;
      *  целочисленные константы в десятичной системе счисления, помещающиеся в 32-битный знаковый целочисленный тип;
      *  круглые скобки для явного обозначения приоритета операций;
      *  произвольное число пробельных символов в любом месте, не влияющем на однозначность понимания формулы (например, между операцией и переменной, но не внутри констант).
*  Приоритет операций, начиная с наивысшего
   *  унарный минус;
   *  умножение и деление;
   *  сложение и вычитание.
*  Класс `ExpressionParser` реализовывает интерфейс `TripleParser`. Результат разбора реализует интерфейс `TripleExpression`
*  Реализованы бинарные операции (минимальный приоритет):
   * `set` – установка бита, `2 set 3` равно 10;
   * `clear` – сброс бита, `10 clear 3` равно 2.
*  Реализована унарная операция
   * `count` – число установленных битов, `count -5` равно 31.

*  В программу, вычисляющую выражения, добалена обработка ошибок, в том числе:
      *  ошибки разбора выражений;
      *  ошибки вычисления выражений.
*  Класс `ExpressionParser` реализует интерфейс `TripleParser`
*  Классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`, `CheckedDivide` и `CheckedNegate` реализует интерфейс `TripleExpression`
